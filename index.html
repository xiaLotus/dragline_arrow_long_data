<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>K11 ä¸­æ§å®¤ç›£æ§</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
  .node {
    width: 115px;
    height: 110x;
  }
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }
  .blinking {
    animation: blink 1s infinite;
  }
  @keyframes border-blink-amber {
    0%, 100% { border-color: rgb(245 158 11); }
    50% { border-color: transparent; }
  }
  @keyframes border-blink-red {
    0%, 100% { border-color: rgb(239 68 68); }
    50% { border-color: transparent; }
  }
  .border-blinking-amber {
    animation: border-blink-amber 1s infinite;
  }
  .border-blinking-red {
    animation: border-blink-red 1s infinite;
  }
  @keyframes image-cycle {
    0%, 49% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }
  @keyframes image-cycle-reverse {
    0%, 49% { opacity: 0; }
    50%, 100% { opacity: 1; }
  }
  .image-cycling-1 {
    animation: image-cycle 2s infinite;
  }
  .image-cycling-2 {
    animation: image-cycle-reverse 2s infinite;
  }
  
  /* é¸æ“‡ç‹€æ…‹æ¨£å¼ */
  .node-selected {
    border: 3px solid #3b82f6 !important;
    box-shadow: 0 0 15px rgba(59, 130, 246, 0.5) !important;
    transform: scale(1.02);
    z-index: 20 !important;
  }
  
  .node-selectable {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  </style>
</head>
<body class="bg-gray-100 p-0 m-0">
  <div id="app" class="relative w-screen h-screen overflow-hidden">
    <!-- é¡¯ç¤ºæ›´æ–°æ™‚é–“ + æ¨™é¡Œ + ç¯©é¸æŒ‰éˆ• -->
    <div class="flex justify-between items-center h-[64px] bg-white text-gray-800 text-2xl font-bold tracking-wide px-4">
      <!-- æ›´æ–°æ™‚é–“é å·¦ -->
      <div class="text-sm text-gray-600 flex flex-col leading-tight">
        <div v-if="lastUpdate">ä¸Šæ¬¡æ›´æ–°ï¼š{{ lastUpdate }}</div>
        <div v-if="nextUpdate">ä¸‹æ¬¡æ›´æ–°ï¼š28åˆ†é˜å¾Œ</div>
      </div>

      <!-- ä¸­å¤®ç½®ä¸­æ–‡å­— -->
      <h1 class="text-center">K11  ä¸­æ§å®¤</h1>
      
      <!-- ç¯©é¸æŒ‰éˆ•é å³ -->
      <div class="flex items-center space-x-3">
        <!-- é¸æ“‡ç‹€æ…‹é¡¯ç¤º -->
        <div v-if="selectedNodes.length > 0" class="text-xs text-blue-600 bg-blue-50 px-3 py-2 rounded-lg border border-blue-200">
          <div class="font-medium">å·²é¸æ“‡: {{ selectedNodes.length }} å€‹ç«™é»</div>
          <button @click="clearSelection" class="text-red-500 hover:text-red-700 text-xs mt-1">æ¸…é™¤é¸æ“‡</button>
        </div>
        
        <!-- ä¸‹æ‹‰å¼é¸å–® -->
        <div class="relative">
          <button 
            @click="toggleDropdown($event)"
            :class="[
              'flex items-center px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 border-2',
              getFilterButtonStyle()
            ]"
          >
            <span>{{ getFilterLabel() }}</span>
            <svg 
              :class="['ml-2 h-4 w-4 transition-transform duration-200', showDropdown ? 'rotate-180' : '']"
              fill="none" 
              stroke="currentColor" 
              viewBox="0 0 24 24"
            >
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
          </button>
          
          <!-- ä¸‹æ‹‰é¸å–® -->
          <div 
            v-show="showDropdown"
            @click="stopPropagation($event)"
            class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-gray-200 z-50 py-1"
          >
            <button
              v-for="option in filterOptions"
              :key="option.value"
              @click="selectFilterOption(option.value, $event)"
              :class="[
                'w-full text-left px-4 py-3 text-sm transition-colors duration-150 flex items-center',
                currentFilter === option.value 
                  ? 'bg-blue-50 text-blue-700 border-r-4 border-blue-500' 
                  : 'text-gray-700 hover:bg-gray-50'
              ]"
            >
              <div 
                :class="[
                  'w-3 h-3 rounded-full mr-3',
                  option.color
                ]"
              ></div>
              <div>
                <div class="font-medium">{{ option.label }}</div>
                <div class="text-xs text-gray-500">{{ option.count }} å€‹ç«™é»</div>
              </div>
            </button>
          </div>
        </div>
        
        <!-- çµ±è¨ˆä¿¡æ¯ -->
        <div class="text-xs text-gray-500 bg-gray-100 px-3 py-2 rounded-lg">
          <div class="font-medium">{{ getFilterLabel() }}</div>
          <div>{{ getFilteredCount() }} / {{ nodes.length }} ç«™é»</div>
        </div>
      </div>
    </div>
    <div style="height: 30px; width: 100%;"></div>
    <!-- ç¯€é»å®¹å™¨ - å®Œå…¨ç½®ä¸­ä¸¦ç¢ºä¿å·¦å³å°ç¨± -->
    <div class="flex justify-center items-center" style="height: calc(100vh - 64px - 100px); overflow: hidden;">
      <div class="relative" :style="{ width: (containerWidth + 120) + 'px', height: (containerHeight + 50) + 'px' }">
        <!-- SVG ç·šæ¢å±¤ -->
        <svg class="absolute top-6 left-0 z-0 pointer-events-none" :style="{ width: (containerWidth + 120) + 'px', height: containerHeight + 'px' }">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
            </marker>
            <marker id="arrowhead-pink" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#e91e63" />
            </marker>
          </defs>

          <!-- æ­£å¸¸çš„é€£æ¥ç·š -->
          <line
            v-for="(line, i) in lines"
            :key="'line-' + i"
            :x1="line.x1 + 60"
            :y1="line.y1"
            :x2="line.x2 + 60"
            :y2="line.y2"
            stroke="#94a3b8"
            stroke-width="2"
            marker-end="url(#arrowhead)"
          />
          
          <!-- å‹•æ…‹ç”Ÿæˆè½‰å½ç®­é ­ -->
          <template v-for="arrow in getCornerArrows()" :key="`corner-${arrow.fromId}-${arrow.toId}`">
            <!-- ä½¿ç”¨å–®ä¸€è·¯å¾‘ç¹ªè£½å®Œæ•´çš„è½‰è§’ç®­é ­ -->
            <path
              :d="getCompleteCornerPath(arrow.fromId, arrow.toId, arrow.direction)"
              stroke="#e91e63"
              stroke-width="2"
              fill="none"
              marker-end="url(#arrowhead-pink)"
            />
          </template>
          
          <!-- å›ºå®šè½‰è§’ç®­é ­ - åœ¨æ­£å¸¸æ¨¡å¼ä¸‹é¡¯ç¤º -->
          <template v-if="!showOnlyAutomation">
            <!-- å‹•æ…‹ç”Ÿæˆçš„è½‰è§’ç®­é ­å·²ç¶“åœ¨ä¸Šé¢è™•ç† -->
          </template>
          
          <!-- è‡ªå‹•åŒ–æ¨¡å¼ä¸‹çš„è½‰è§’ç®­é ­ -->
          <template v-if="showOnlyAutomation">
            <!-- å‹•æ…‹ç”Ÿæˆçš„è½‰è§’ç®­é ­å·²ç¶“åœ¨ä¸Šé¢è™•ç† -->
          </template>
          
        </svg>

        <!-- ç¯€é»å®¹å™¨ -->
        <div class="relative" style="top: 25px; left: 60px;">
          <!-- ç¯€é»æ¨™ç±¤å±¤ - åœ¨ç¯€é»ä¸Šæ–¹ -->
          <div
            v-for="(node, index) in filteredNodes"
            :key="'label-' + node.id"
            class="absolute text-center font-bold text-blue-600 text-sm z-20 pointer-events-none"
            :style="{ 
              top: (node.top - 24) + 'px', 
              left: node.left + 'px',
              width: '125px'
            }"
          >
            {{ node.label }}
          </div>
          
          <!-- ç¯€é»å…ƒç´  -->
          <div
            v-for="(node, index) in filteredNodes"
            :key="node.id"
            :class="[
              'node bg-white border-2 shadow-md text-center font-normal text-gray-700 text-xs py-1 flex flex-col justify-start items-center absolute cursor-pointer z-10 node-selectable transition-all duration-200',
              {
                'border-blue-500': !node.outerlight_color || node.outerlight_color === 'blue' || node.outerlight_color === 'blue-500',
                'border-4 border-blinking-amber': node.outerlight_color === 'amber' || node.outerlight_color === 'amber-500' || node.outerlight_color === 'amber-600',
                'border-4 border-blinking-red': node.outerlight_color === 'rose-300' || node.outerlight_color === 'rose-400',
                'node-selected': isNodeSelected(node.id)
              }
            ]"
            :style="{ top: node.top + 'px', left: node.left + 'px' }"
            @click="toggleNodeSelection(node.id, $event)"
            @mousedown="startDrag($event, index)"
            style="width: 125px; height: 100px; border-radius: 0.375rem; overflow: hidden;"
          >
            <!-- å¤–å±¤æ§åˆ¶å‚ç›´å°é½Š -->
            <div class="flex flex-col items-center flex-grow w-full pt-1 pb-2 px-1" :class="(node.name && node.name.length) ? 'justify-between' : 'justify-center'">
              <!-- ç‹€æ…‹æŒ‡ç¤ºå™¨éƒ¨åˆ† -->
              <div class="flex items-center justify-center"> 
                <!-- å§‹çµ‚é¡¯ç¤ºåœ–ç‰‡å®¹å™¨ -->
                <div :class="['rounded w-4 h-3 flex items-center justify-center border-red-400 border border-solid', node.light === 'on' ? 'blinking' : '']" style="position: relative;"> 
                  <!-- ç•¶ light ä¸æ˜¯ on æ™‚ï¼Œé¡¯ç¤ºå›ºå®šåœ–ç‰‡ -->
                  <div v-if="node.light !== 'on'" class="w-3 h-2 bg-blue-500 rounded flex items-center justify-center text-white text-[7px]">M</div>
                  
                  <!-- ç•¶ light æ˜¯ on æ™‚ï¼Œé¡¯ç¤ºå¾ªç’°åœ–ç‰‡ -->
                  <template v-if="node.light === 'on'">
                    <div class="w-3 h-2 bg-blue-500 rounded flex items-center justify-center text-white text-[7px] image-cycling-1" style="position: absolute;">M</div> 
                    <div class="w-3 h-2 bg-red-500 rounded flex items-center justify-center text-white text-[7px] image-cycling-2" style="position: absolute;">X</div>
                  </template>
                </div> 
              </div>

              <!-- WIP è³‡è¨Šéƒ¨åˆ† -->
              <div v-if="node.name && node.name.length" class="flex flex-col items-center text-xs font-normal text-gray-700 border-t border-gray-300 pt-1 mt-1 w-full px-1"> 
                <div v-for="(line, i) in node.name" :key="i" class="w-full mb-1">
                  <!-- é€²åº¦æ¢å®¹å™¨ - å›ºå®šé«˜åº¦ -->
                  <div class="w-full bg-gray-100 rounded relative shadow-inner border border-gray-200" style="height: 16px;">
                    <!-- é€²åº¦æ¢èƒŒæ™¯æ¼¸å±¤ -->
                    <div class="rounded transition-all duration-500 ease-out shadow-sm relative" style="height: 16px;" :class="{'bg-gradient-to-r from-blue-400 to-blue-500': node.wip_percent < 80, 'bg-gradient-to-r from-amber-400 to-amber-500': node.wip_percent >= 80 && node.wip_percent < 90, 'bg-gradient-to-r from-red-400 to-red-500': node.wip_percent >= 90}" :style="{ width: Math.max((node.wip_percent || 0), 15) + '%' }">
                      <!-- ç™¾åˆ†æ¯”æ•¸å­— - åœ¨é€²åº¦æ¢ç¯„åœå…§å±…ä¸­ -->
                      <div class="absolute inset-0 flex items-center justify-center text-[9px] font-bold tracking-wide text-white">{{ node.wip_percent || 0 }}%</div>
                    </div>
                  </div>
                </div>
              </div> 
            </div>

            <!-- åº•éƒ¨ç‹€æ…‹é•·æ–¹å½¢ -->
            <div class="absolute bottom-0 left-0 w-full h-4 flex text-[6px] leading-tight">
              <div class="w-1/2 flex items-center justify-center px-1 text-center" :class="node.last_color || 'bg-gray-200'">
                <div class="whitespace-pre-line break-words leading-tight" style="font-size: 6px;">
                  å‰å…©å°æ™‚ {{ node.last || "" }}
                </div>
              </div>
              <div class="w-1/2 flex items-center justify-center px-1 text-center" :class="node.now_color || 'bg-gray-300'">
                <div class="whitespace-pre-line break-words leading-tight" style="font-size: 6px;">
                  å‰ä¸€å°æ™‚ {{ node.now || "" }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨ç©ºé–“å€åŸŸ -->
    <div class="absolute bottom-0 left-0 w-full bg-gray-50 border-t border-gray-200" style="height: 50px;">
      <div class="flex items-center justify-center h-full text-gray-500">
        <!-- é€™è£¡å¯ä»¥æ”¾ç½®åº•éƒ¨å…§å®¹ -->
        <p>é ç•™ç©ºé–“ (50px)</p>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          nodes: [],
          selectedNodes: [], // æ–°å¢ï¼šå„²å­˜é¸ä¸­çš„ç¯€é»ID
          lastUpdate: null,
          nextUpdate: null,
          containerWidth: 1450,
          containerHeight: 550,
          offset: { x: 0, y: 0 },
          draggingIndex: null,
          isDragging: false, // æ–°å¢ï¼šè¿½è¹¤æ˜¯å¦æ­£åœ¨æ‹–æ‹½
          lines: [],
          showOnlyAutomation: false,
          currentFilter: 'all',
          showDropdown: false,
          filterOptions: [
            { 
              value: 'all', 
              label: 'å…¨éƒ¨ç«™é»', 
              color: 'bg-gray-400',
              count: 0
            },
            { 
              value: 'front', 
              label: 'å‰æ®µ', 
              color: 'bg-green-400',
              count: 0
            },
            { 
              value: 'middle', 
              label: 'ä¸­å¾Œæ®µ', 
              color: 'bg-orange-400',
              count: 0
            },
            { 
              value: 'automation', 
              label: 'è‡ªå‹•åŒ–', 
              color: 'bg-blue-400',
              count: 0
            }
          ]
        };
      },
      computed: {
        filteredNodes() {
          let filtered = this.nodes;
          
          switch (this.currentFilter) {
            case 'front':
              filtered = this.nodes.filter(node => node.stage === 'å‰æ®µ');
              break;
            case 'middle':
              filtered = this.nodes.filter(node => node.stage === 'ä¸­å¾Œæ®µ');
              break;
            case 'automation':
              filtered = this.nodes.filter(node => node.automation === 'V');
              break;
            default:
              filtered = this.nodes;
          }
          
          // å¦‚æœä¸æ˜¯é¡¯ç¤ºå…¨éƒ¨ï¼Œå‰‡é‡æ–°æ’åˆ—ç¯€é»
          if (this.currentFilter !== 'all') {
            const sortedNodes = filtered.sort((a, b) => a.id - b.id);
            const repositioned = this.repositionToFront(sortedNodes);
            
            // å»¶é²åŸ·è¡Œè¦–åœ–è·³è½‰ï¼Œç¢ºä¿ç¯€é»å·²é‡æ–°æ’åˆ—
            setTimeout(() => {
              this.autoJumpToStage();
            }, 50);
            
            return repositioned;
          }
          
          return filtered;
        },
        automationCount() {
          return this.nodes.filter(node => node.automation === 'V').length;
        },
        frontStageCount() {
          return this.nodes.filter(node => node.stage === 'å‰æ®µ').length;
        },
        middleStageCount() {
          return this.nodes.filter(node => node.stage === 'ä¸­å¾Œæ®µ').length;
        }
      },
      mounted() {
        console.log('Vue æ‡‰ç”¨å·²è¼‰å…¥');
        this.calculateOptimalLayout();
        this.fetchAndRender();
        this.startAutoUpdate();
        window.addEventListener("mousemove", this.onDrag);
        window.addEventListener("mouseup", this.endDrag);
        window.addEventListener("resize", this.calculateOptimalLayout);
        // é»æ“Šå¤–éƒ¨é—œé–‰ä¸‹æ‹‰é¸å–®
        window.addEventListener("click", this.closeDropdown);
      },
      methods: {
        // æ–°å¢ï¼šæª¢æŸ¥ç¯€é»æ˜¯å¦è¢«é¸ä¸­
        isNodeSelected(nodeId) {
          return this.selectedNodes.includes(nodeId);
        },
        
        // æ–°å¢ï¼šåˆ‡æ›ç¯€é»é¸æ“‡ç‹€æ…‹
        toggleNodeSelection(nodeId, event) {
          // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œä¸é€²è¡Œé¸æ“‡
          if (this.isDragging) return;
          
          event.stopPropagation();
          
          const index = this.selectedNodes.indexOf(nodeId);
          if (index > -1) {
            // å¦‚æœå·²é¸ä¸­ï¼Œå‰‡å–æ¶ˆé¸æ“‡
            this.selectedNodes.splice(index, 1);
          } else {
            // å¦‚æœæœªé¸ä¸­ï¼Œå‰‡æ·»åŠ åˆ°é¸æ“‡åˆ—è¡¨
            this.selectedNodes.push(nodeId);
          }
        },
        
        // æ–°å¢ï¼šæ¸…é™¤æ‰€æœ‰é¸æ“‡
        clearSelection() {
          this.selectedNodes = [];
        },
        
        calculateOptimalLayout() {
          const availableWidth = window.innerWidth - 120;
          const availableHeight = window.innerHeight - 64 - 100 - 40;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          const cols = 11;
          const rows = 5;
          
          const minGapX = 8;
          const minGapY = 25;
          
          const idealGapX = Math.max(minGapX, (availableWidth - cols * nodeWidth) / (cols - 1));
          const idealGapY = Math.max(minGapY, (availableHeight - rows * nodeHeight) / (rows - 1));
          
          this.containerWidth = (cols - 1) * (nodeWidth + idealGapX) + nodeWidth;
          this.containerHeight = (rows - 1) * (nodeHeight + idealGapY) + nodeHeight;
          
          this.repositionNodes(idealGapX, idealGapY);
        },
        
        repositionNodes(gapX, gapY) {
          if (!this.nodes.length) return;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          this.nodes.forEach(node => {
            const row = Math.floor((node.id - 1) / 11);
            const col = (node.id - 1) % 11;
            
            if (row % 2 === 0) {
              node.left = col * (nodeWidth + gapX);
            } else {
              node.left = (10 - col) * (nodeWidth + gapX);
            }
            node.top = row * (nodeHeight + gapY);
          });
          
          this.updateLines();
        },
        
        repositionToFront(filteredNodes) {
          // è¤‡è£½ç¯€é»é¿å…ä¿®æ”¹åŸå§‹æ•¸æ“š
          const repositionedNodes = filteredNodes.map((node, index) => ({ 
            ...node,
            // é‡æ–°ç·¨è™Ÿç‚ºé€£çºŒçš„ ID
            displayId: index + 1,
            // ä¿ç•™åŸå§‹ ID ç”¨æ–¼å…¶ä»–ç”¨é€”
            originalId: node.id
          }));
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          // ä½¿ç”¨èˆ‡åŸæœ¬ä½ˆå±€ç›¸åŒçš„é–“è·
          const availableWidth = window.innerWidth - 120;
          const availableHeight = window.innerHeight - 64 - 100 - 40;
          const cols = 11;
          const rows = 5;
          const minGapX = 8;
          const minGapY = 25;
          const idealGapX = Math.max(minGapX, (availableWidth - cols * nodeWidth) / (cols - 1));
          const idealGapY = Math.max(minGapY, (availableHeight - rows * nodeHeight) / (rows - 1));
          
          repositionedNodes.forEach((node, index) => {
            const row = Math.floor(index / cols);
            const col = index % cols;
            
            // ä½¿ç”¨èˆ‡åŸæœ¬ç›¸åŒçš„è›‡å½¢æ’åˆ—é‚è¼¯
            if (row % 2 === 0) {
              // å¶æ•¸è¡Œï¼šå¾å·¦åˆ°å³
              node.left = col * (nodeWidth + idealGapX);
            } else {
              // å¥‡æ•¸è¡Œï¼šå¾å³åˆ°å·¦
              node.left = (cols - 1 - col) * (nodeWidth + idealGapX);
            }
            node.top = row * (nodeHeight + idealGapY);
          });
          
          // ç¯©é¸æ¨¡å¼æ™‚è‡ªå‹•å±…ä¸­é¡¯ç¤º
          this.$nextTick(() => {
            this.centerFilteredNodes(repositionedNodes);
          });
          
          return repositionedNodes;
        },
        
        // æ–°å¢ï¼šå°‡ç¯©é¸çš„ç¯€é»å±…ä¸­é¡¯ç¤º
        centerFilteredNodes(nodes) {
          if (!nodes.length || this.currentFilter === 'all') return;
          
          setTimeout(() => {
            // é‡ç½®ä»»ä½•ä¹‹å‰çš„è®Šæ›
            const nodeContainer = document.querySelector('.relative[style*="top: 25px"]');
            if (nodeContainer) {
              nodeContainer.style.transform = 'translate(0px, 0px)';
            }
          }, 100);
        },
        
        toggleFilter() {
          this.showOnlyAutomation = !this.showOnlyAutomation;
          this.$nextTick(() => {
            this.updateLines();
            // é‡ç½®è¦–åœ–ä½ç½®
            this.resetViewPosition();
          });
        },
        
        // æ–°å¢ï¼šé‡ç½®è¦–åœ–ä½ç½®
        resetViewPosition() {
          const nodeContainer = document.querySelector('.relative[style*="top: 25px"]');
          if (nodeContainer) {
            nodeContainer.style.transition = 'transform 0.5s ease-in-out';
            nodeContainer.style.transform = 'translate(0px, 0px)';
            setTimeout(() => {
              nodeContainer.style.transition = '';
            }, 500);
          }
        },
        
        // æ–°å¢ï¼šåˆ‡æ›ä¸‹æ‹‰é¸å–®
        toggleDropdown(event) {
          event.stopPropagation();
          this.showDropdown = !this.showDropdown;
        },
        
        // æ–°å¢ï¼šé˜»æ­¢äº‹ä»¶å†’æ³¡
        stopPropagation(event) {
          event.stopPropagation();
        },
        
        // æ–°å¢ï¼šé¸æ“‡ç¯©é¸é¸é …
        selectFilterOption(filterValue, event) {
          event.stopPropagation();
          this.currentFilter = filterValue;
          this.showDropdown = false;
          
          // è‡ªå‹•è·³è½‰åˆ°å°æ‡‰çš„ stage è¦–åœ–
          this.$nextTick(() => {
            this.updateLines();
          });
        },
        
        // æ–°å¢ï¼šé—œé–‰ä¸‹æ‹‰é¸å–®
        closeDropdown() {
          this.showDropdown = false;
        },
        
        // ç§»é™¤è¤‡é›œçš„é©—è­‰é‚è¼¯ï¼Œç›´æ¥ä½¿ç”¨ç°¡åŒ–çš„è½‰å½ç®­é ­è¨ˆç®—
        autoJumpToStage() {
          if (this.currentFilter === 'all') {
            this.resetViewPosition();
            return;
          }
          
          // æ ¹æ“šç¯©é¸æ¢ä»¶æ±ºå®šè·³è½‰ä½ç½®
          let targetPosition = { x: 0, y: 0 };
          
          switch (this.currentFilter) {
            case 'front':
              // å‰æ®µï¼šè·³è½‰åˆ°ä¸Šæ–¹ï¼ˆç¬¬ä¸€è¡Œï¼‰
              targetPosition = { x: 0, y: 50 };
              break;
            case 'middle':
              // ä¸­å¾Œæ®µï¼šè·³è½‰åˆ°ä¸‹æ–¹ï¼ˆå¾Œé¢å¹¾è¡Œï¼‰
              targetPosition = { x: 0, y: -100 };
              break;
            case 'automation':
              // è‡ªå‹•åŒ–ï¼šå±…ä¸­é¡¯ç¤º
              targetPosition = { x: 0, y: 0 };
              break;
          }
          
          // æ‡‰ç”¨å¹³æ»‘è·³è½‰å‹•ç•«
          const nodeContainer = document.querySelector('.relative[style*="top: 25px"]');
          if (nodeContainer) {
            nodeContainer.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
            nodeContainer.style.transform = `translate(${targetPosition.x}px, ${targetPosition.y}px)`;
            
            // æ¸…é™¤å‹•ç•«æ•ˆæœï¼Œä½†ä¿æŒä½ç½®
            setTimeout(() => {
              nodeContainer.style.transition = '';
            }, 800);
          }
        },
        
        getFilterLabel() {
          const option = this.filterOptions.find(opt => opt.value === this.currentFilter);
          return option ? option.label : 'å…¨éƒ¨ç«™é»';
        },
        
        getFilterButtonStyle() {
          switch (this.currentFilter) {
            case 'front':
              return 'bg-green-50 text-green-700 border-green-300 hover:bg-green-100';
            case 'middle':
              return 'bg-orange-50 text-orange-700 border-orange-300 hover:bg-orange-100';
            case 'automation':
              return 'bg-blue-50 text-blue-700 border-blue-300 hover:bg-blue-100';
            default:
              return 'bg-gray-50 text-gray-700 border-gray-300 hover:bg-gray-100';
          }
        },
        
        getFilteredCount() {
          return this.filteredNodes.length;
        },
        
        updateFilterCounts() {
          this.filterOptions.forEach(option => {
            switch (option.value) {
              case 'all':
                option.count = this.nodes.length;
                break;
              case 'front':
                option.count = this.frontStageCount;
                break;
              case 'middle':
                option.count = this.middleStageCount;
                break;
              case 'automation':
                option.count = this.automationCount;
                break;
            }
          });
        },
        
        fetchAndRender() {
          console.log('ğŸ”„ æ­£åœ¨æ’ˆå–è³‡æ–™...');
          fetch('http://127.0.0.1:5000/nodes')
            .then(res => {
              console.log('API å›æ‡‰ç‹€æ…‹:', res.status);
              if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
              }
              return res.json();
            })
            .then(data => {
              console.log('âœ… è³‡æ–™æ’ˆå–æˆåŠŸï¼Œå…±æœ‰ç¯€é»ï¼š', data.length);
              this.nodes = data;
              this.updateFilterCounts();
              this.calculateOptimalLayout();
              const now = new Date();
              now.setMilliseconds(0);
              this.lastUpdate = this.getNowTime(now);
              this.updateNextUpdateTime();
              console.log('ğŸ•’ æ›´æ–°æ™‚é–“ç‚ºï¼š', this.lastUpdate);
            })
            .catch(err => {
              console.error('âŒ è³‡æ–™æ’ˆå–å¤±æ•—ï¼š', err);
              this.loadTestData();
            });
        },
        
        loadTestData() {
          console.log('ğŸ“ è¼‰å…¥æ¸¬è©¦è³‡æ–™...');
          this.nodes = [];
          
          for (let i = 1; i <= 55; i++) {
            let targets = [];
            if (i === 11) {
              targets = [12];
            } else if (i === 22) {
              targets = [23];
            } else if (i === 33) {
              targets = [34];
            } else if (i === 44) {
              targets = [45];
            } else if (i === 55) {
              targets = [];
            } else if (i < 55 && i !== 11 && i !== 22 && i !== 33 && i !== 44) {
              targets = [i + 1];
            }
            
            this.nodes.push({
              "id": i,
              "label": i.toString(),
              "name": [],
              "top": 0,
              "left": 0,
              "targets": targets,
              "last": "",
              "last_color": "bg-gray-200",
              "now": "",
              "now_color": "bg-gray-200",
              "light": "off",
              "outerlight": "off",
              "outerlight_color": "blue",
              "goal": "",
              "wip_percent": 0,
              "automation": "X"
            });
          }
          
          this.calculateOptimalLayout();
          this.updateFilterCounts();
          const now = new Date();
          this.lastUpdate = this.getNowTime(now);
          console.log('âœ… ç”Ÿæˆäº†55å€‹æ¸¬è©¦ç¯€é»');
        },
        
        getNowTime(date = new Date()) {
          const yyyy = date.getFullYear();
          const mm = String(date.getMonth() + 1).padStart(2, '0');
          const dd = String(date.getDate()).padStart(2, '0');
          const hh = String(date.getHours()).padStart(2, '0');
          const mi = String(date.getMinutes()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}, ${hh}:${mi}`;
        },
        
        updateNextUpdateTime() {
          const now = new Date();
          const next = new Date(now.getTime() + 28 * 60 * 1000);
          this.nextUpdate = this.getNowTime(next);
        },
        
        startAutoUpdate() {
          const interval = 28 * 60 * 1000;
          this.updateNextUpdateTime();
          
          setInterval(() => {
            this.fetchAndRender();
            this.updateNextUpdateTime();
          }, interval);
        },
        
        startDrag(e, index) {
          if (e.target.classList.contains('select-text') || e.target.closest('.select-text')) return;
          
          this.isDragging = false; // åˆå§‹åŒ–æ‹–æ‹½ç‹€æ…‹
          this.draggingIndex = index;
          const node = this.filteredNodes[index];
          this.offset.x = e.clientX - node.left;
          this.offset.y = e.clientY - node.top;
        },

        onDrag(e) {
          if (this.draggingIndex !== null) {
            this.isDragging = true; // æ¨™è¨˜ç‚ºæ‹–æ‹½ä¸­
            const node = this.filteredNodes[this.draggingIndex];
            const boxWidth = 125;
            const boxHeight = 110;

            let newLeft = e.clientX - this.offset.x;
            let newTop = e.clientY - this.offset.y;

            newLeft = Math.max(0, Math.min(this.containerWidth - boxWidth, newLeft));
            newTop = Math.max(0, Math.min(this.containerHeight - boxHeight, newTop));

            node.left = newLeft;
            node.top = newTop;

            this.$nextTick(this.updateLines);
          }
        },
        
        endDrag() {
          // å»¶é²é‡ç½®æ‹–æ‹½ç‹€æ…‹ï¼Œé¿å…å½±éŸ¿é»æ“Šäº‹ä»¶
          setTimeout(() => {
            this.isDragging = false;
          }, 50);
          this.draggingIndex = null;
        },
        
        getCompleteCornerPath(fromId, toId, direction) {
          const fromNode = this.filteredNodes.find(n => n.id === fromId);
          const toNode = this.filteredNodes.find(n => n.id === toId);
          
          if (!fromNode || !toNode) return '';
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          const fromNodeLeft = fromNode.left + 60;
          const fromNodeTop = fromNode.top;
          const toNodeLeft = toNode.left + 60;
          const toNodeTop = toNode.top;
          
          if (direction === 'right') {
            // å³å´è½‰è§’ï¼šå¾ç¯€é»å³å´å‡ºä¾†ï¼Œå‘å³å»¶ä¼¸ï¼Œå‘ä¸‹è½‰ï¼Œå†å‘å·¦é€²å…¥ä¸‹ä¸€å€‹ç¯€é»çš„å³å´
            const startX = fromNodeLeft + nodeWidth;
            const startY = fromNodeTop + nodeHeight / 2;
            const cornerX = startX + 35;
            const endX = toNodeLeft + nodeWidth + 2;  // åœåœ¨ç¯€é»å³å´é‚Šç·£å¤–2åƒç´ 
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${cornerX} ${startY} L ${cornerX} ${endY} L ${endX} ${endY}`;
          } else {
            // å·¦å´è½‰è§’ï¼šå¾ç¯€é»å·¦å´å‡ºä¾†ï¼Œå‘å·¦å»¶ä¼¸ï¼Œå‘ä¸‹è½‰ï¼Œå†å‘å³é€²å…¥ä¸‹ä¸€å€‹ç¯€é»çš„å·¦å´
            const startX = fromNodeLeft;
            const startY = fromNodeTop + nodeHeight / 2;
            const cornerX = startX - 35;
            const endX = toNodeLeft - 2;  // åœåœ¨ç¯€é»å·¦å´é‚Šç·£å¤–2åƒç´ 
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${cornerX} ${startY} L ${cornerX} ${endY} L ${endX} ${endY}`;
          }
        },
        
        getCornerArrows() {
          const corners = [];
          const visibleNodes = this.filteredNodes;
          const cols = 11;
          
          if (this.currentFilter !== 'all') {
            // ç¯©é¸æ¨¡å¼ï¼šåªåœ¨ç‰¹å®šä½ç½®ç”Ÿæˆè½‰å½ç®­é ­
            const totalNodes = visibleNodes.length;
            
            // æ˜ç¢ºå®šç¾©è½‰å½ä½ç½®ï¼šæ¯è¡Œçš„ç¬¬11å€‹ç¯€é»(ç´¢å¼•10, 21, 32, 43)è½‰å‘ä¸‹ä¸€è¡Œç¬¬1å€‹ç¯€é»
            const turnPositions = [
              { from: 10, to: 11, direction: 'right' },  // ç¬¬1è¡Œæœ« â†’ ç¬¬2è¡Œé ­
              { from: 21, to: 22, direction: 'left' },   // ç¬¬2è¡Œæœ« â†’ ç¬¬3è¡Œé ­  
              { from: 32, to: 33, direction: 'right' },  // ç¬¬3è¡Œæœ« â†’ ç¬¬4è¡Œé ­
              { from: 43, to: 44, direction: 'left' }    // ç¬¬4è¡Œæœ« â†’ ç¬¬5è¡Œé ­
            ];
            
            for (const pos of turnPositions) {
              // åªæœ‰ç•¶ç¯€é»æ•¸é‡è¶³å¤ æ™‚æ‰ç”Ÿæˆè½‰å½ç®­é ­
              if (pos.to < totalNodes) {
                const fromNode = visibleNodes[pos.from];
                const toNode = visibleNodes[pos.to];
                
                if (fromNode && toNode) {
                  corners.push({
                    fromId: fromNode.id,
                    toId: toNode.id,
                    direction: pos.direction
                  });
                }
              }
            }
          } else {
            // æ­£å¸¸æ¨¡å¼ï¼šåªåœ¨æœ€å·¦å´å’Œæœ€å³å´ç”¢ç”Ÿè½‰å½ç®­é ­
            // æ ¹æ“šæ‚¨çš„åœ–ç‰‡ï¼Œé€™äº›æ˜¯å›ºå®šçš„è½‰å½ä½ç½®
            const edgeConnections = [
              { fromId: 11, toId: 12, direction: 'right' },  // å³å´è½‰å½
              { fromId: 22, toId: 23, direction: 'left' },   // å·¦å´è½‰å½
              { fromId: 33, toId: 34, direction: 'right' },  // å³å´è½‰å½
              { fromId: 44, toId: 45, direction: 'left' }    // å·¦å´è½‰å½
            ];
            
            for (const conn of edgeConnections) {
              const fromNode = visibleNodes.find(n => n.id === conn.fromId);
              const toNode = visibleNodes.find(n => n.id === conn.toId);
              if (fromNode && toNode) {
                corners.push(conn);
              }
            }
          }
          
          return corners;
        },
        
        getArrowPath(fromId, toId, direction) {
          const fromNode = this.filteredNodes.find(n => n.id === fromId);
          const toNode = this.filteredNodes.find(n => n.id === toId);
          
          if (!fromNode || !toNode) return '';
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          const fromNodeLeft = fromNode.left + 60;
          const fromNodeTop = fromNode.top;
          const toNodeLeft = toNode.left + 60;
          const toNodeTop = toNode.top;
          
          if (direction === 'right') {
            const startX = fromNodeLeft + nodeWidth;
            const startY = fromNodeTop + nodeHeight / 2;
            const rightX = startX + 35;
            const endX = toNodeLeft;
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${rightX} ${startY} L ${rightX} ${endY} L ${endX} ${endY}`;
          } else {
            const startX = fromNodeLeft;
            const startY = fromNodeTop + nodeHeight / 2;
            const leftX = startX - 35;
            const endX = toNodeLeft + nodeWidth;
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${leftX} ${startY} L ${leftX} ${endY} L ${endX} ${endY}`;
          }
        },
        
        getCornerArrow(fromId, toId, direction) {
          const fromNode = this.filteredNodes.find(n => n.id === fromId);
          const toNode = this.filteredNodes.find(n => n.id === toId);
          
          if (!fromNode || !toNode) return null;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          const fromNodeLeft = fromNode.left + 60;
          const fromNodeTop = fromNode.top;
          const toNodeLeft = toNode.left + 60;
          const toNodeTop = toNode.top;
          
          if (direction === 'right') {
            // å¾å³å´ç¯€é»çš„å³é‚Šå‡ºä¾†
            const startX = fromNodeLeft + nodeWidth;
            const startY = fromNodeTop + nodeHeight / 2;
            const rightX = startX + 35;
            const endX = toNodeLeft;
            const endY = toNodeTop + nodeHeight / 2;
            
            // æ°´å¹³ç·šæ®µï¼šå¾ç¯€é»å³å´å»¶ä¼¸
            const horizontal = `M ${startX} ${startY} L ${rightX} ${startY}`;
            // å‚ç›´ç·šæ®µï¼šå‘ä¸‹é€£æ¥
            const vertical = `M ${rightX} ${startY} L ${rightX} ${endY}`;
            
            return { horizontal, vertical };
          } else {
            // å¾å·¦å´ç¯€é»çš„å·¦é‚Šå‡ºä¾†
            const startX = fromNodeLeft;
            const startY = fromNodeTop + nodeHeight / 2;
            const leftX = startX - 35;
            const endX = toNodeLeft + nodeWidth;
            const endY = toNodeTop + nodeHeight / 2;
            
            // æ°´å¹³ç·šæ®µï¼šå¾ç¯€é»å·¦å´å»¶ä¼¸
            const horizontal = `M ${startX} ${startY} L ${leftX} ${startY}`;
            // å‚ç›´ç·šæ®µï¼šå‘ä¸‹é€£æ¥
            const vertical = `M ${leftX} ${startY} L ${leftX} ${endY}`;
            
            return { horizontal, vertical };
          }
        },
        
        getEdgeArrow(nodeId, side) {
          const node = this.filteredNodes.find(n => n.id === nodeId);
          if (!node) return '';
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          const nodeLeft = node.left + 60;
          const nodeTop = node.top;
          
          if (side === 'right-left') {
            // å¾å·¦å´é€²å…¥ç¯€é»
            const endX = nodeLeft;
            const endY = nodeTop + nodeHeight / 2;
            const startX = endX - 35;
            return `M ${startX} ${endY} L ${endX} ${endY}`;
          } else if (side === 'left-right') {
            // å¾å³å´é€²å…¥ç¯€é»
            const endX = nodeLeft + nodeWidth;
            const endY = nodeTop + nodeHeight / 2;
            const startX = endX + 35;
            return `M ${startX} ${endY} L ${endX} ${endY}`;
          }
          
          return '';
        },
        
        updateLines() {
          const boxWidth = 125;
          const boxHeight = 110;
          this.lines = [];
          
          const visibleNodes = this.filteredNodes;
          const cornerArrows = this.getCornerArrows();
          const cornerConnections = new Set(cornerArrows.map(arrow => `${arrow.fromId}-${arrow.toId}`));

          if (this.currentFilter !== 'all') {
            // ç¯©é¸æ¨¡å¼ï¼šæŒ‰è›‡å½¢ä½ˆå±€é‚è¼¯é€£æ¥ç¯€é»
            const cols = 11;
            
            for (let i = 0; i < visibleNodes.length - 1; i++) {
              const source = visibleNodes[i];
              const target = visibleNodes[i + 1];
              const row = Math.floor(i / cols);
              const col = i % cols;
              
              // è·³éè½‰å½ç®­é ­çš„é€£æ¥
              if (cornerConnections.has(`${source.id}-${target.id}`)) {
                continue;
              }
              
              // æª¢æŸ¥æ˜¯å¦åœ¨åŒä¸€è¡Œ
              const nextRow = Math.floor((i + 1) / cols);
              if (row !== nextRow) {
                continue; // è·¨è¡Œé€£æ¥ç”±è½‰å½ç®­é ­è™•ç†
              }
              
              // æª¢æŸ¥æ˜¯å¦æ‡‰è©²é€£æ¥
              let shouldConnect = false;
              
              if (row % 2 === 0) {
                // å¶æ•¸è¡Œï¼šå¾å·¦åˆ°å³ï¼Œæª¢æŸ¥ä¸æ˜¯è¡Œæœ«
                shouldConnect = (col < cols - 1);
              } else {
                // å¥‡æ•¸è¡Œï¼šå¾å³åˆ°å·¦ï¼Œæª¢æŸ¥ä¸æ˜¯è¡Œé¦–
                shouldConnect = (col > 0);
              }
              
              if (!shouldConnect) {
                continue;
              }
              
              const sx = source.left + boxWidth / 2;
              const sy = source.top + boxHeight / 2;
              const tx = target.left + boxWidth / 2;
              const ty = target.top + boxHeight / 2;

              let x1, y1, x2, y2;
              
              if (row % 2 === 0) {
                // å¶æ•¸è¡Œï¼šå¾å·¦åˆ°å³é€£æ¥
                x1 = sx + boxWidth / 2;
                y1 = sy;
                x2 = tx - boxWidth / 2;
                y2 = ty;
              } else {
                // å¥‡æ•¸è¡Œï¼šå¾å³åˆ°å·¦é€£æ¥
                x1 = sx - boxWidth / 2;
                y1 = sy;
                x2 = tx + boxWidth / 2;
                y2 = ty;
              }

              this.lines.push({ x1, y1, x2, y2 });
            }
          } else {
            // æ­£å¸¸æ¨¡å¼ï¼šä½¿ç”¨åŸå§‹çš„ targets é€£æ¥é‚è¼¯
            for (const source of visibleNodes) {
              const sx = source.left + boxWidth / 2;
              const sy = source.top + boxHeight / 2;

              for (const targetId of source.targets) {
                const target = visibleNodes.find(n => n.id === targetId);
                if (!target) continue;

                // è·³éè½‰å½ç®­é ­çš„é€£æ¥
                if (cornerConnections.has(`${source.id}-${targetId}`)) {
                  continue;
                }

                const tx = target.left + boxWidth / 2;
                const ty = target.top + boxHeight / 2;

                const dx = tx - sx;
                const dy = ty - sy;
                const angle = Math.atan2(dy, dx);

                const offsetX = Math.cos(angle) * (boxWidth / 2);
                const offsetY = Math.sin(angle) * (boxHeight / 2);

                const x1 = sx + offsetX;
                const y1 = sy + offsetY;
                const x2 = tx - offsetX;
                const y2 = ty - offsetY;

                this.lines.push({ x1, y1, x2, y2 });
              }
            }
          }
        }
      }
    }).mount("#app");
  </script>
</body>
</html>