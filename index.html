<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>K11 ä¸­æ§å®¤ç›£æ§</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
  .node {
    width: 115px;
    height: 110x;
  }
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }
  .blinking {
    animation: blink 1s infinite;
  }
  @keyframes border-blink-amber {
    0%, 100% { border-color: rgb(245 158 11); }
    50% { border-color: transparent; }
  }
  @keyframes border-blink-red {
    0%, 100% { border-color: rgb(239 68 68); }
    50% { border-color: transparent; }
  }
  .border-blinking-amber {
    animation: border-blink-amber 1s infinite;
  }
  .border-blinking-red {
    animation: border-blink-red 1s infinite;
  }
  @keyframes image-cycle {
    0%, 49% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }
  @keyframes image-cycle-reverse {
    0%, 49% { opacity: 0; }
    50%, 100% { opacity: 1; }
  }
  .image-cycling-1 {
    animation: image-cycle 2s infinite;
  }
  .image-cycling-2 {
    animation: image-cycle-reverse 2s infinite;
  }
  </style>
</head>
<body class="bg-gray-100 p-0 m-0">
  <div id="app" class="relative w-screen h-screen overflow-hidden">
    <!-- é¡¯ç¤ºæ›´æ–°æ™‚é–“ + æ¨™é¡Œ + ç¯©é¸æŒ‰éˆ• -->
    <div class="flex justify-between items-center h-[64px] bg-white text-gray-800 text-2xl font-bold tracking-wide px-4">
      <!-- æ›´æ–°æ™‚é–“é å·¦ -->
      <div class="text-sm text-gray-600 flex flex-col leading-tight">
        <div v-if="lastUpdate">ä¸Šæ¬¡æ›´æ–°ï¼š{{ lastUpdate }}</div>
        <div v-if="nextUpdate">ä¸‹æ¬¡æ›´æ–°ï¼š28åˆ†é˜å¾Œ</div>
      </div>

      <!-- ä¸­å¤®ç½®ä¸­æ–‡å­— -->
      <h1 class="text-center">K11  ä¸­æ§å®¤</h1>
      
      <!-- ç¯©é¸æŒ‰éˆ•é å³ -->
      <div class="flex items-center space-x-2">
        <button 
          @click="toggleFilter"
          :class="[
            'px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200',
            showOnlyAutomation 
              ? 'bg-blue-500 text-white shadow-md hover:bg-blue-600' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          ]"
        >
          {{ showOnlyAutomation ? 'é¡¯ç¤ºå…¨éƒ¨' : 'åªé¡¯ç¤ºè‡ªå‹•åŒ–' }}
        </button>
        <div class="text-xs text-gray-500">
          {{ showOnlyAutomation ? `è‡ªå‹•åŒ–ç«™é»: ${automationCount}` : `ç¸½ç«™é»: ${nodes.length}` }}
        </div>
      </div>
    </div>
    <div style="height: 30px; width: 100%;"></div>
    <!-- ç¯€é»å®¹å™¨ - å®Œå…¨ç½®ä¸­ä¸¦ç¢ºä¿å·¦å³å°ç¨± -->
    <div class="flex justify-center items-center" style="height: calc(100vh - 64px - 100px); overflow: hidden;">
      <div class="relative" :style="{ width: (containerWidth + 120) + 'px', height: (containerHeight + 50) + 'px' }">
        <!-- SVG ç·šæ¢å±¤ -->
        <svg class="absolute top-6 left-0 z-0 pointer-events-none" :style="{ width: (containerWidth + 120) + 'px', height: containerHeight + 'px' }">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
            </marker>
            <marker id="arrowhead-pink" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#e91e63" />
            </marker>
          </defs>

          <!-- æ­£å¸¸çš„é€£æ¥ç·š -->
          <line
            v-for="(line, i) in lines"
            :key="'line-' + i"
            :x1="line.x1 + 60"
            :y1="line.y1"
            :x2="line.x2 + 60"
            :y2="line.y2"
            stroke="#94a3b8"
            stroke-width="2"
            marker-end="url(#arrowhead)"
          />
          
          <!-- ç‰¹æ®Šç›´è§’ç®­é ­ - å‹•æ…‹è¨ˆç®—è½‰å½ä½ç½® -->
          <template v-if="shouldShowSpecialArrows">
            <!-- å‹•æ…‹ç”Ÿæˆè½‰å½ç®­é ­ -->
            <path
              v-for="arrow in getCornerArrows()"
              :key="`corner-${arrow.fromId}-${arrow.toId}`"
              :d="getArrowPath(arrow.fromId, arrow.toId, arrow.direction)"
              stroke="#e91e63"
              stroke-width="3"
              fill="none"
              marker-end="url(#arrowhead-pink)"
            />
          </template>
        </svg>

        <!-- ç¯€é»å®¹å™¨ -->
        <div class="relative" style="top: 25px; left: 60px;">
          <!-- ç¯€é»æ¨™ç±¤å±¤ - åœ¨ç¯€é»ä¸Šæ–¹ -->
          <div
            v-for="(node, index) in filteredNodes"
            :key="'label-' + node.id"
            class="absolute text-center font-bold text-blue-600 text-sm z-20 pointer-events-none"
            :style="{ 
              top: (node.top - 24) + 'px', 
              left: node.left + 'px',
              width: '125px'
            }"
          >
            {{ node.label }}
          </div>
          
          <!-- ç¯€é»å…ƒç´  -->
          <div
            v-for="(node, index) in filteredNodes"
            :key="node.id"
            :class="[
              'node bg-white border-2 shadow-md text-center font-normal text-gray-700 text-xs py-1 flex flex-col justify-start items-center absolute cursor-move z-10',
              {
                'border-blue-500': !node.outerlight_color || node.outerlight_color === 'blue' || node.outerlight_color === 'blue-500',
                'border-4 border-blinking-amber': node.outerlight_color === 'amber' || node.outerlight_color === 'amber-500' || node.outerlight_color === 'amber-600',
                'border-4 border-blinking-red': node.outerlight_color === 'rose-300' || node.outerlight_color === 'rose-400'
              }
            ]"
            :style="{ top: node.top + 'px', left: node.left + 'px' }"
            @mousedown="startDrag($event, index)"
            style="width: 125px; height: 100px; border-radius: 0.375rem; overflow: hidden;"
          >
            <!-- å¤–å±¤æ§åˆ¶å‚ç›´å°é½Š -->
            <div class="flex flex-col items-center flex-grow w-full pt-1 pb-2 px-1" :class="(node.name && node.name.length) ? 'justify-between' : 'justify-center'">
              <!-- ç‹€æ…‹æŒ‡ç¤ºå™¨éƒ¨åˆ† -->
              <div class="flex items-center justify-center"> 
                <!-- å§‹çµ‚é¡¯ç¤ºåœ–ç‰‡å®¹å™¨ -->
                <div :class="['rounded w-4 h-3 flex items-center justify-center border-red-400 border border-solid', node.light === 'on' ? 'blinking' : '']" style="position: relative;"> 
                  <!-- ç•¶ light ä¸æ˜¯ on æ™‚ï¼Œé¡¯ç¤ºå›ºå®šåœ–ç‰‡ -->
                  <div v-if="node.light !== 'on'" class="w-3 h-2 bg-blue-500 rounded flex items-center justify-center text-white text-[7px]">M</div>
                  
                  <!-- ç•¶ light æ˜¯ on æ™‚ï¼Œé¡¯ç¤ºå¾ªç’°åœ–ç‰‡ -->
                  <template v-if="node.light === 'on'">
                    <div class="w-3 h-2 bg-blue-500 rounded flex items-center justify-center text-white text-[7px] image-cycling-1" style="position: absolute;">M</div> 
                    <div class="w-3 h-2 bg-red-500 rounded flex items-center justify-center text-white text-[7px] image-cycling-2" style="position: absolute;">X</div>
                  </template>
                </div> 
              </div>

              <!-- WIP è³‡è¨Šéƒ¨åˆ† -->
              <div v-if="node.name && node.name.length" class="flex flex-col items-center text-xs font-normal text-gray-700 border-t border-gray-300 pt-1 mt-1 w-full px-1"> 
                <div v-for="(line, i) in node.name" :key="i" class="w-full mb-1">
                  <!-- é€²åº¦æ¢å®¹å™¨ - å›ºå®šé«˜åº¦ -->
                  <div class="w-full bg-gray-100 rounded relative shadow-inner border border-gray-200" style="height: 16px;">
                    <!-- é€²åº¦æ¢èƒŒæ™¯æ¼¸å±¤ -->
                    <div class="rounded transition-all duration-500 ease-out shadow-sm relative" style="height: 16px;" :class="{'bg-gradient-to-r from-blue-400 to-blue-500': node.wip_percent < 80, 'bg-gradient-to-r from-amber-400 to-amber-500': node.wip_percent >= 80 && node.wip_percent < 90, 'bg-gradient-to-r from-red-400 to-red-500': node.wip_percent >= 90}" :style="{ width: Math.max((node.wip_percent || 0), 15) + '%' }">
                      <!-- ç™¾åˆ†æ¯”æ•¸å­— - åœ¨é€²åº¦æ¢ç¯„åœå…§å±…ä¸­ -->
                      <div class="absolute inset-0 flex items-center justify-center text-[9px] font-bold tracking-wide text-white">{{ node.wip_percent || 0 }}%</div>
                    </div>
                  </div>
                </div>
              </div> 
            </div>

            <!-- åº•éƒ¨ç‹€æ…‹é•·æ–¹å½¢ -->
            <div class="absolute bottom-0 left-0 w-full h-4 flex text-[6px] leading-tight">
              <div class="w-1/2 flex items-center justify-center px-1 text-center" :class="node.last_color || 'bg-gray-200'">
                <div class="whitespace-pre-line break-words leading-tight" style="font-size: 6px;">
                  å‰å…©å°æ™‚ {{ node.last || "" }}
                </div>
              </div>
              <div class="w-1/2 flex items-center justify-center px-1 text-center" :class="node.now_color || 'bg-gray-300'">
                <div class="whitespace-pre-line break-words leading-tight" style="font-size: 6px;">
                  å‰ä¸€å°æ™‚ {{ node.now || "" }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨ç©ºé–“å€åŸŸ -->
    <div class="absolute bottom-0 left-0 w-full bg-gray-50 border-t border-gray-200" style="height: 50px;">
      <div class="flex items-center justify-center h-full text-gray-500">
        <!-- é€™è£¡å¯ä»¥æ”¾ç½®åº•éƒ¨å…§å®¹ -->
        <p>é ç•™ç©ºé–“ (50px)</p>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          nodes: [],
          lastUpdate: null,
          nextUpdate: null,
          containerWidth: 1450,
          containerHeight: 550,
          offset: { x: 0, y: 0 },
          draggingIndex: null,
          lines: [],
          showOnlyAutomation: false
        };
      },
      computed: {
        filteredNodes() {
          if (this.showOnlyAutomation) {
            const automationNodes = this.nodes.filter(node => node.automation === 'V');
            // æŒ‰ç…§åŸæœ¬çš„æµç¨‹é †åºæ’åºï¼ˆæ ¹æ“š IDï¼‰
            const sortedNodes = automationNodes.sort((a, b) => a.id - b.id);
            // é‡æ–°å®šä½åˆ°å‰é¢çš„ä½ç½®
            return this.repositionToFront(sortedNodes);
          }
          return this.nodes;
        },
        automationCount() {
          return this.nodes.filter(node => node.automation === 'V').length;
        },
        shouldShowSpecialArrows() {
          // åœ¨å…©ç¨®æ¨¡å¼ä¸‹éƒ½é¡¯ç¤ºç‰¹æ®Šç®­é ­ï¼Œåªè¦ç›¸é—œç¯€é»å­˜åœ¨
          return true;
        }
      },
      mounted() {
        console.log('Vue æ‡‰ç”¨å·²è¼‰å…¥');
        this.calculateOptimalLayout();
        this.fetchAndRender();
        this.startAutoUpdate();
        window.addEventListener("mousemove", this.onDrag);
        window.addEventListener("mouseup", this.endDrag);
        window.addEventListener("resize", this.calculateOptimalLayout);
      },
      methods: {
        calculateOptimalLayout() {
          const availableWidth = window.innerWidth - 120;
          const availableHeight = window.innerHeight - 64 - 100 - 40;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          const cols = 11;
          const rows = 5;
          
          const minGapX = 8;
          const minGapY = 25;
          
          const idealGapX = Math.max(minGapX, (availableWidth - cols * nodeWidth) / (cols - 1));
          const idealGapY = Math.max(minGapY, (availableHeight - rows * nodeHeight) / (rows - 1));
          
          this.containerWidth = (cols - 1) * (nodeWidth + idealGapX) + nodeWidth;
          this.containerHeight = (rows - 1) * (nodeHeight + idealGapY) + nodeHeight;
          
          this.repositionNodes(idealGapX, idealGapY);
        },
        
        repositionNodes(gapX, gapY) {
          if (!this.nodes.length) return;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          this.nodes.forEach(node => {
            const row = Math.floor((node.id - 1) / 11);
            const col = (node.id - 1) % 11;
            
            if (row % 2 === 0) {
              node.left = col * (nodeWidth + gapX);
            } else {
              node.left = (10 - col) * (nodeWidth + gapX);
            }
            node.top = row * (nodeHeight + gapY);
          });
          
          this.updateLines();
        },
        
        fetchAndRender() {
          console.log('ğŸ”„ æ­£åœ¨æ’ˆå–è³‡æ–™...');
          fetch('http://127.0.0.1:5000/nodes')
            .then(res => {
              console.log('API å›æ‡‰ç‹€æ…‹:', res.status);
              if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
              }
              return res.json();
            })
            .then(data => {
              console.log('âœ… è³‡æ–™æ’ˆå–æˆåŠŸï¼Œå…±æœ‰ç¯€é»ï¼š', data.length);
              this.nodes = data;
              this.calculateOptimalLayout();
              const now = new Date();
              now.setMilliseconds(0);
              this.lastUpdate = this.getNowTime(now);
              this.updateNextUpdateTime();
              console.log('ğŸ•’ æ›´æ–°æ™‚é–“ç‚ºï¼š', this.lastUpdate);
            })
            .catch(err => {
              console.error('âŒ è³‡æ–™æ’ˆå–å¤±æ•—ï¼š', err);
              this.loadTestData();
            });
        },
        
        loadTestData() {
          console.log('ğŸ“ è¼‰å…¥æ¸¬è©¦è³‡æ–™...');
          this.nodes = [];
          
          for (let i = 1; i <= 55; i++) {
            let targets = [];
            if (i === 11) {
              targets = [12];
            } else if (i === 22) {
              targets = [23];
            } else if (i === 33) {
              targets = [34];
            } else if (i === 44) {
              targets = [45];
            } else if (i === 55) {
              targets = [];
            } else if (i < 55 && i !== 11 && i !== 22 && i !== 33 && i !== 44) {
              targets = [i + 1];
            }
            
            this.nodes.push({
              "id": i,
              "label": i.toString(),
              "name": [],
              "top": 0,
              "left": 0,
              "targets": targets,
              "last": "",
              "last_color": "bg-gray-200",
              "now": "",
              "now_color": "bg-gray-200",
              "light": "off",
              "outerlight": "off",
              "outerlight_color": "blue",
              "goal": "",
              "wip_percent": 0,
              "automation": "X"
            });
          }
          
          this.calculateOptimalLayout();
          const now = new Date();
          this.lastUpdate = this.getNowTime(now);
          console.log('âœ… ç”Ÿæˆäº†55å€‹æ¸¬è©¦ç¯€é»');
        },
        
        getNowTime(date = new Date()) {
          const yyyy = date.getFullYear();
          const mm = String(date.getMonth() + 1).padStart(2, '0');
          const dd = String(date.getDate()).padStart(2, '0');
          const hh = String(date.getHours()).padStart(2, '0');
          const mi = String(date.getMinutes()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}, ${hh}:${mi}`;
        },
        
        updateNextUpdateTime() {
          const now = new Date();
          const next = new Date(now.getTime() + 28 * 60 * 1000);
          this.nextUpdate = this.getNowTime(next);
        },
        
        startAutoUpdate() {
          const interval = 28 * 60 * 1000;
          this.updateNextUpdateTime();
          
          setInterval(() => {
            this.fetchAndRender();
            this.updateNextUpdateTime();
          }, interval);
        },
        
        repositionToFront(automationNodes) {
          // è¤‡è£½ç¯€é»é¿å…ä¿®æ”¹åŸå§‹æ•¸æ“š
          const repositionedNodes = automationNodes.map(node => ({ ...node }));
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          // ä½¿ç”¨èˆ‡åŸæœ¬ä½ˆå±€ç›¸åŒçš„é–“è·
          const availableWidth = window.innerWidth - 120;
          const availableHeight = window.innerHeight - 64 - 100 - 40;
          const cols = 11;
          const rows = 5;
          const minGapX = 8;
          const minGapY = 25;
          const idealGapX = Math.max(minGapX, (availableWidth - cols * nodeWidth) / (cols - 1));
          const idealGapY = Math.max(minGapY, (availableHeight - rows * nodeHeight) / (rows - 1));
          
          repositionedNodes.forEach((node, index) => {
            const row = Math.floor(index / cols);
            const col = index % cols;
            
            // ä½¿ç”¨èˆ‡åŸæœ¬ç›¸åŒçš„è›‡å½¢æ’åˆ—é‚è¼¯
            if (row % 2 === 0) {
              // å¶æ•¸è¡Œï¼šå¾å·¦åˆ°å³
              node.left = col * (nodeWidth + idealGapX);
            } else {
              // å¥‡æ•¸è¡Œï¼šå¾å³åˆ°å·¦
              node.left = (cols - 1 - col) * (nodeWidth + idealGapX);
            }
            node.top = row * (nodeHeight + idealGapY);
          });
          
          return repositionedNodes;
        },
        
        toggleFilter() {
          this.showOnlyAutomation = !this.showOnlyAutomation;
          this.$nextTick(() => {
            this.updateLines();
          });
        },
        
        hasSpecialConnection(fromId, toId) {
          // æª¢æŸ¥å…©å€‹ç¯€é»æ˜¯å¦éƒ½åœ¨ç•¶å‰é¡¯ç¤ºçš„ç¯€é»ä¸­
          const fromNode = this.filteredNodes.find(n => n.id === fromId);
          const toNode = this.filteredNodes.find(n => n.id === toId);
          return fromNode && toNode;
        },
        
        startDrag(e, index) {
          if (e.target.classList.contains('select-text') || e.target.closest('.select-text')) return;
          this.draggingIndex = index;
          const node = this.filteredNodes[index];
          this.offset.x = e.clientX - node.left;
          this.offset.y = e.clientY - node.top;
        },

        onDrag(e) {
          if (this.draggingIndex !== null) {
            const node = this.filteredNodes[this.draggingIndex];
            const boxWidth = 125;
            const boxHeight = 110;

            let newLeft = e.clientX - this.offset.x;
            let newTop = e.clientY - this.offset.y;

            newLeft = Math.max(0, Math.min(this.containerWidth - boxWidth, newLeft));
            newTop = Math.max(0, Math.min(this.containerHeight - boxHeight, newTop));

            node.left = newLeft;
            node.top = newTop;

            this.$nextTick(this.updateLines);
          }
        },
        
        endDrag() {
          this.draggingIndex = null;
        },
        
        getArrowPath(fromId, toId, direction) {
          let fromNode, toNode;
          
          if (this.showOnlyAutomation) {
            // åœ¨è‡ªå‹•åŒ–æ¨¡å¼ä¸‹ï¼Œä½¿ç”¨é‡æ–°æ’åˆ—å¾Œçš„ç¯€é»ä½ç½®
            fromNode = this.filteredNodes.find(n => n.id === fromId);
            toNode = this.filteredNodes.find(n => n.id === toId);
          } else {
            // åœ¨æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œä½¿ç”¨åŸå§‹ç¯€é»ä½ç½®
            fromNode = this.filteredNodes.find(n => n.id === fromId);
            toNode = this.filteredNodes.find(n => n.id === toId);
          }
          
          if (!fromNode || !toNode) return '';
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          const fromNodeLeft = fromNode.left + 60;
          const fromNodeTop = fromNode.top;
          const toNodeLeft = toNode.left + 60;
          const toNodeTop = toNode.top;
          
          if (direction === 'right') {
            const startX = fromNodeLeft + nodeWidth;
            const startY = fromNodeTop + nodeHeight / 2;
            const rightX = startX + 35;
            const endX = toNodeLeft;
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${rightX} ${startY} L ${rightX} ${endY} L ${endX} ${endY}`;
          } else {
            const startX = fromNodeLeft;
            const startY = fromNodeTop + nodeHeight / 2;
            const leftX = startX - 35;
            const endX = toNodeLeft + nodeWidth;
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${leftX} ${startY} L ${leftX} ${endY} L ${endX} ${endY}`;
          }
        },
        
        updateLines() {
          const boxWidth = 125;
          const boxHeight = 110;
          this.lines = [];
          
          const visibleNodes = this.filteredNodes;
          const cornerArrows = this.getCornerArrows();
          const cornerConnections = new Set(cornerArrows.map(arrow => `${arrow.fromId}-${arrow.toId}`));

          if (this.showOnlyAutomation) {
            // è‡ªå‹•åŒ–æ¨¡å¼ï¼šæ ¹æ“šå¯¦éš›æ’åˆ—é †åºé€£æ¥ï¼Œè·³éè½‰å½ç®­é ­
            for (let i = 0; i < visibleNodes.length - 1; i++) {
              const source = visibleNodes[i];
              const target = visibleNodes[i + 1];
              
              // è·³éè½‰å½ç®­é ­çš„é€£æ¥
              if (cornerConnections.has(`${source.id}-${target.id}`)) {
                continue;
              }
              
              const sx = source.left + boxWidth / 2;
              const sy = source.top + boxHeight / 2;
              const tx = target.left + boxWidth / 2;
              const ty = target.top + boxHeight / 2;

              const dx = tx - sx;
              const dy = ty - sy;
              const angle = Math.atan2(dy, dx);

              const offsetX = Math.cos(angle) * (boxWidth / 2);
              const offsetY = Math.sin(angle) * (boxHeight / 2);

              const x1 = sx + offsetX;
              const y1 = sy + offsetY;
              const x2 = tx - offsetX;
              const y2 = ty - offsetY;

              this.lines.push({ x1, y1, x2, y2 });
            }
          } else {
            // æ­£å¸¸æ¨¡å¼ï¼šä½¿ç”¨åŸå§‹çš„ targets é€£æ¥é‚è¼¯
            for (const source of visibleNodes) {
              const sx = source.left + boxWidth / 2;
              const sy = source.top + boxHeight / 2;

              for (const targetId of source.targets) {
                const target = visibleNodes.find(n => n.id === targetId);
                if (!target) continue;

                // è·³éè½‰å½ç®­é ­çš„é€£æ¥
                if (cornerConnections.has(`${source.id}-${targetId}`)) {
                  continue;
                }

                const tx = target.left + boxWidth / 2;
                const ty = target.top + boxHeight / 2;

                const dx = tx - sx;
                const dy = ty - sy;
                const angle = Math.atan2(dy, dx);

                const offsetX = Math.cos(angle) * (boxWidth / 2);
                const offsetY = Math.sin(angle) * (boxHeight / 2);

                const x1 = sx + offsetX;
                const y1 = sy + offsetY;
                const x2 = tx - offsetX;
                const y2 = ty - offsetY;

                this.lines.push({ x1, y1, x2, y2 });
              }
            }
          }
        },
        
        getCornerArrows() {
          const corners = [];
          const visibleNodes = this.filteredNodes;
          const cols = 11;
          
          if (this.showOnlyAutomation) {
            // è‡ªå‹•åŒ–æ¨¡å¼ï¼šæ ¹æ“šå¯¦éš›æ’åˆ—è¨ˆç®—è½‰å½ç®­é ­
            for (let i = 0; i < visibleNodes.length; i++) {
              const row = Math.floor(i / cols);
              const col = i % cols;
              
              // æª¢æŸ¥æ˜¯å¦æ˜¯è¡Œæœ«ç¯€é»ä¸”æœ‰ä¸‹ä¸€è¡Œ
              const isLastInRow = (col === cols - 1) || (i === visibleNodes.length - 1);
              const nextRowStartIndex = (row + 1) * cols;
              
              if (isLastInRow && nextRowStartIndex < visibleNodes.length) {
                const currentNode = visibleNodes[i];
                const nextRowFirstNode = visibleNodes[nextRowStartIndex];
                
                if (currentNode && nextRowFirstNode) {
                  // æ ¹æ“šè¡Œæ•¸æ±ºå®šè½‰å½æ–¹å‘
                  const direction = row % 2 === 0 ? 'right' : 'left';
                  corners.push({
                    fromId: currentNode.id,
                    toId: nextRowFirstNode.id,
                    direction: direction
                  });
                }
              }
            }
          } else {
            // æ­£å¸¸æ¨¡å¼ï¼šä½¿ç”¨åŸå§‹çš„å›ºå®šè½‰å½é‚è¼¯
            const specialConnections = [
              { fromId: 11, toId: 12, direction: 'right' },
              { fromId: 22, toId: 23, direction: 'left' },
              { fromId: 33, toId: 34, direction: 'right' },
              { fromId: 44, toId: 45, direction: 'left' }
            ];
            
            for (const conn of specialConnections) {
              if (this.hasSpecialConnection(conn.fromId, conn.toId)) {
                corners.push(conn);
              }
            }
          }
          
          return corners;
        },
        
        getNodePosition(nodeId, nodeList) {
          const node = nodeList.find(n => n.id === nodeId);
          return node ? { left: node.left, top: node.top } : { left: 0, top: 0 };
        }
      }
    }).mount("#app");
  </script>
</body>
</html>