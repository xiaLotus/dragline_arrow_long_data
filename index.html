<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>K11 中控室監控</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
  .node {
    width: 115px;
    height: 110x;
  }
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }
  .blinking {
    animation: blink 1s infinite;
  }
  @keyframes border-blink-amber {
    0%, 100% { border-color: rgb(245 158 11); }
    50% { border-color: transparent; }
  }
  @keyframes border-blink-red {
    0%, 100% { border-color: rgb(239 68 68); }
    50% { border-color: transparent; }
  }
  .border-blinking-amber {
    animation: border-blink-amber 1s infinite;
  }
  .border-blinking-red {
    animation: border-blink-red 1s infinite;
  }
  @keyframes image-cycle {
    0%, 49% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }
  @keyframes image-cycle-reverse {
    0%, 49% { opacity: 0; }
    50%, 100% { opacity: 1; }
  }
  .image-cycling-1 {
    animation: image-cycle 2s infinite;
  }
  .image-cycling-2 {
    animation: image-cycle-reverse 2s infinite;
  }
  </style>
</head>
<body class="bg-gray-100 p-0 m-0">
  <div id="app" class="relative w-screen h-screen overflow-hidden">
    <!-- 顯示更新時間 + 標題 + 篩選按鈕 -->
    <div class="flex justify-between items-center h-[64px] bg-white text-gray-800 text-2xl font-bold tracking-wide px-4">
      <!-- 更新時間靠左 -->
      <div class="text-sm text-gray-600 flex flex-col leading-tight">
        <div v-if="lastUpdate">上次更新：{{ lastUpdate }}</div>
        <div v-if="nextUpdate">下次更新：28分鐘後</div>
      </div>

      <!-- 中央置中文字 -->
      <h1 class="text-center">K11  中控室</h1>
      
      <!-- 篩選按鈕靠右 -->
      <div class="flex items-center space-x-2">
        <button 
          @click="toggleFilter"
          :class="[
            'px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200',
            showOnlyAutomation 
              ? 'bg-blue-500 text-white shadow-md hover:bg-blue-600' 
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          ]"
        >
          {{ showOnlyAutomation ? '顯示全部' : '只顯示自動化' }}
        </button>
        <div class="text-xs text-gray-500">
          {{ showOnlyAutomation ? `自動化站點: ${automationCount}` : `總站點: ${nodes.length}` }}
        </div>
      </div>
    </div>
    <div style="height: 30px; width: 100%;"></div>
    <!-- 節點容器 - 完全置中並確保左右對稱 -->
    <div class="flex justify-center items-center" style="height: calc(100vh - 64px - 100px); overflow: hidden;">
      <div class="relative" :style="{ width: (containerWidth + 120) + 'px', height: (containerHeight + 50) + 'px' }">
        <!-- SVG 線條層 -->
        <svg class="absolute top-6 left-0 z-0 pointer-events-none" :style="{ width: (containerWidth + 120) + 'px', height: containerHeight + 'px' }">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
            </marker>
            <marker id="arrowhead-pink" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="userSpaceOnUse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#e91e63" />
            </marker>
          </defs>

          <!-- 正常的連接線 -->
          <line
            v-for="(line, i) in lines"
            :key="'line-' + i"
            :x1="line.x1 + 60"
            :y1="line.y1"
            :x2="line.x2 + 60"
            :y2="line.y2"
            stroke="#94a3b8"
            stroke-width="2"
            marker-end="url(#arrowhead)"
          />
          
          <!-- 特殊直角箭頭 - 動態計算轉彎位置 -->
          <template v-if="shouldShowSpecialArrows">
            <!-- 動態生成轉彎箭頭 -->
            <path
              v-for="arrow in getCornerArrows()"
              :key="`corner-${arrow.fromId}-${arrow.toId}`"
              :d="getArrowPath(arrow.fromId, arrow.toId, arrow.direction)"
              stroke="#e91e63"
              stroke-width="3"
              fill="none"
              marker-end="url(#arrowhead-pink)"
            />
          </template>
        </svg>

        <!-- 節點容器 -->
        <div class="relative" style="top: 25px; left: 60px;">
          <!-- 節點標籤層 - 在節點上方 -->
          <div
            v-for="(node, index) in filteredNodes"
            :key="'label-' + node.id"
            class="absolute text-center font-bold text-blue-600 text-sm z-20 pointer-events-none"
            :style="{ 
              top: (node.top - 24) + 'px', 
              left: node.left + 'px',
              width: '125px'
            }"
          >
            {{ node.label }}
          </div>
          
          <!-- 節點元素 -->
          <div
            v-for="(node, index) in filteredNodes"
            :key="node.id"
            :class="[
              'node bg-white border-2 shadow-md text-center font-normal text-gray-700 text-xs py-1 flex flex-col justify-start items-center absolute cursor-move z-10',
              {
                'border-blue-500': !node.outerlight_color || node.outerlight_color === 'blue' || node.outerlight_color === 'blue-500',
                'border-4 border-blinking-amber': node.outerlight_color === 'amber' || node.outerlight_color === 'amber-500' || node.outerlight_color === 'amber-600',
                'border-4 border-blinking-red': node.outerlight_color === 'rose-300' || node.outerlight_color === 'rose-400'
              }
            ]"
            :style="{ top: node.top + 'px', left: node.left + 'px' }"
            @mousedown="startDrag($event, index)"
            style="width: 125px; height: 100px; border-radius: 0.375rem; overflow: hidden;"
          >
            <!-- 外層控制垂直對齊 -->
            <div class="flex flex-col items-center flex-grow w-full pt-1 pb-2 px-1" :class="(node.name && node.name.length) ? 'justify-between' : 'justify-center'">
              <!-- 狀態指示器部分 -->
              <div class="flex items-center justify-center"> 
                <!-- 始終顯示圖片容器 -->
                <div :class="['rounded w-4 h-3 flex items-center justify-center border-red-400 border border-solid', node.light === 'on' ? 'blinking' : '']" style="position: relative;"> 
                  <!-- 當 light 不是 on 時，顯示固定圖片 -->
                  <div v-if="node.light !== 'on'" class="w-3 h-2 bg-blue-500 rounded flex items-center justify-center text-white text-[7px]">M</div>
                  
                  <!-- 當 light 是 on 時，顯示循環圖片 -->
                  <template v-if="node.light === 'on'">
                    <div class="w-3 h-2 bg-blue-500 rounded flex items-center justify-center text-white text-[7px] image-cycling-1" style="position: absolute;">M</div> 
                    <div class="w-3 h-2 bg-red-500 rounded flex items-center justify-center text-white text-[7px] image-cycling-2" style="position: absolute;">X</div>
                  </template>
                </div> 
              </div>

              <!-- WIP 資訊部分 -->
              <div v-if="node.name && node.name.length" class="flex flex-col items-center text-xs font-normal text-gray-700 border-t border-gray-300 pt-1 mt-1 w-full px-1"> 
                <div v-for="(line, i) in node.name" :key="i" class="w-full mb-1">
                  <!-- 進度條容器 - 固定高度 -->
                  <div class="w-full bg-gray-100 rounded relative shadow-inner border border-gray-200" style="height: 16px;">
                    <!-- 進度條背景漸層 -->
                    <div class="rounded transition-all duration-500 ease-out shadow-sm relative" style="height: 16px;" :class="{'bg-gradient-to-r from-blue-400 to-blue-500': node.wip_percent < 80, 'bg-gradient-to-r from-amber-400 to-amber-500': node.wip_percent >= 80 && node.wip_percent < 90, 'bg-gradient-to-r from-red-400 to-red-500': node.wip_percent >= 90}" :style="{ width: Math.max((node.wip_percent || 0), 15) + '%' }">
                      <!-- 百分比數字 - 在進度條範圍內居中 -->
                      <div class="absolute inset-0 flex items-center justify-center text-[9px] font-bold tracking-wide text-white">{{ node.wip_percent || 0 }}%</div>
                    </div>
                  </div>
                </div>
              </div> 
            </div>

            <!-- 底部狀態長方形 -->
            <div class="absolute bottom-0 left-0 w-full h-4 flex text-[6px] leading-tight">
              <div class="w-1/2 flex items-center justify-center px-1 text-center" :class="node.last_color || 'bg-gray-200'">
                <div class="whitespace-pre-line break-words leading-tight" style="font-size: 6px;">
                  前兩小時 {{ node.last || "" }}
                </div>
              </div>
              <div class="w-1/2 flex items-center justify-center px-1 text-center" :class="node.now_color || 'bg-gray-300'">
                <div class="whitespace-pre-line break-words leading-tight" style="font-size: 6px;">
                  前一小時 {{ node.now || "" }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 底部空間區域 -->
    <div class="absolute bottom-0 left-0 w-full bg-gray-50 border-t border-gray-200" style="height: 50px;">
      <div class="flex items-center justify-center h-full text-gray-500">
        <!-- 這裡可以放置底部內容 -->
        <p>預留空間 (50px)</p>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          nodes: [],
          lastUpdate: null,
          nextUpdate: null,
          containerWidth: 1450,
          containerHeight: 550,
          offset: { x: 0, y: 0 },
          draggingIndex: null,
          lines: [],
          showOnlyAutomation: false
        };
      },
      computed: {
        filteredNodes() {
          if (this.showOnlyAutomation) {
            const automationNodes = this.nodes.filter(node => node.automation === 'V');
            // 按照原本的流程順序排序（根據 ID）
            const sortedNodes = automationNodes.sort((a, b) => a.id - b.id);
            // 重新定位到前面的位置
            return this.repositionToFront(sortedNodes);
          }
          return this.nodes;
        },
        automationCount() {
          return this.nodes.filter(node => node.automation === 'V').length;
        },
        shouldShowSpecialArrows() {
          // 在兩種模式下都顯示特殊箭頭，只要相關節點存在
          return true;
        }
      },
      mounted() {
        console.log('Vue 應用已載入');
        this.calculateOptimalLayout();
        this.fetchAndRender();
        this.startAutoUpdate();
        window.addEventListener("mousemove", this.onDrag);
        window.addEventListener("mouseup", this.endDrag);
        window.addEventListener("resize", this.calculateOptimalLayout);
      },
      methods: {
        calculateOptimalLayout() {
          const availableWidth = window.innerWidth - 120;
          const availableHeight = window.innerHeight - 64 - 100 - 40;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          const cols = 11;
          const rows = 5;
          
          const minGapX = 8;
          const minGapY = 25;
          
          const idealGapX = Math.max(minGapX, (availableWidth - cols * nodeWidth) / (cols - 1));
          const idealGapY = Math.max(minGapY, (availableHeight - rows * nodeHeight) / (rows - 1));
          
          this.containerWidth = (cols - 1) * (nodeWidth + idealGapX) + nodeWidth;
          this.containerHeight = (rows - 1) * (nodeHeight + idealGapY) + nodeHeight;
          
          this.repositionNodes(idealGapX, idealGapY);
        },
        
        repositionNodes(gapX, gapY) {
          if (!this.nodes.length) return;
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          this.nodes.forEach(node => {
            const row = Math.floor((node.id - 1) / 11);
            const col = (node.id - 1) % 11;
            
            if (row % 2 === 0) {
              node.left = col * (nodeWidth + gapX);
            } else {
              node.left = (10 - col) * (nodeWidth + gapX);
            }
            node.top = row * (nodeHeight + gapY);
          });
          
          this.updateLines();
        },
        
        fetchAndRender() {
          console.log('🔄 正在撈取資料...');
          fetch('http://127.0.0.1:5000/nodes')
            .then(res => {
              console.log('API 回應狀態:', res.status);
              if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
              }
              return res.json();
            })
            .then(data => {
              console.log('✅ 資料撈取成功，共有節點：', data.length);
              this.nodes = data;
              this.calculateOptimalLayout();
              const now = new Date();
              now.setMilliseconds(0);
              this.lastUpdate = this.getNowTime(now);
              this.updateNextUpdateTime();
              console.log('🕒 更新時間為：', this.lastUpdate);
            })
            .catch(err => {
              console.error('❌ 資料撈取失敗：', err);
              this.loadTestData();
            });
        },
        
        loadTestData() {
          console.log('📝 載入測試資料...');
          this.nodes = [];
          
          for (let i = 1; i <= 55; i++) {
            let targets = [];
            if (i === 11) {
              targets = [12];
            } else if (i === 22) {
              targets = [23];
            } else if (i === 33) {
              targets = [34];
            } else if (i === 44) {
              targets = [45];
            } else if (i === 55) {
              targets = [];
            } else if (i < 55 && i !== 11 && i !== 22 && i !== 33 && i !== 44) {
              targets = [i + 1];
            }
            
            this.nodes.push({
              "id": i,
              "label": i.toString(),
              "name": [],
              "top": 0,
              "left": 0,
              "targets": targets,
              "last": "",
              "last_color": "bg-gray-200",
              "now": "",
              "now_color": "bg-gray-200",
              "light": "off",
              "outerlight": "off",
              "outerlight_color": "blue",
              "goal": "",
              "wip_percent": 0,
              "automation": "X"
            });
          }
          
          this.calculateOptimalLayout();
          const now = new Date();
          this.lastUpdate = this.getNowTime(now);
          console.log('✅ 生成了55個測試節點');
        },
        
        getNowTime(date = new Date()) {
          const yyyy = date.getFullYear();
          const mm = String(date.getMonth() + 1).padStart(2, '0');
          const dd = String(date.getDate()).padStart(2, '0');
          const hh = String(date.getHours()).padStart(2, '0');
          const mi = String(date.getMinutes()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}, ${hh}:${mi}`;
        },
        
        updateNextUpdateTime() {
          const now = new Date();
          const next = new Date(now.getTime() + 28 * 60 * 1000);
          this.nextUpdate = this.getNowTime(next);
        },
        
        startAutoUpdate() {
          const interval = 28 * 60 * 1000;
          this.updateNextUpdateTime();
          
          setInterval(() => {
            this.fetchAndRender();
            this.updateNextUpdateTime();
          }, interval);
        },
        
        repositionToFront(automationNodes) {
          // 複製節點避免修改原始數據
          const repositionedNodes = automationNodes.map(node => ({ ...node }));
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          // 使用與原本佈局相同的間距
          const availableWidth = window.innerWidth - 120;
          const availableHeight = window.innerHeight - 64 - 100 - 40;
          const cols = 11;
          const rows = 5;
          const minGapX = 8;
          const minGapY = 25;
          const idealGapX = Math.max(minGapX, (availableWidth - cols * nodeWidth) / (cols - 1));
          const idealGapY = Math.max(minGapY, (availableHeight - rows * nodeHeight) / (rows - 1));
          
          repositionedNodes.forEach((node, index) => {
            const row = Math.floor(index / cols);
            const col = index % cols;
            
            // 使用與原本相同的蛇形排列邏輯
            if (row % 2 === 0) {
              // 偶數行：從左到右
              node.left = col * (nodeWidth + idealGapX);
            } else {
              // 奇數行：從右到左
              node.left = (cols - 1 - col) * (nodeWidth + idealGapX);
            }
            node.top = row * (nodeHeight + idealGapY);
          });
          
          return repositionedNodes;
        },
        
        toggleFilter() {
          this.showOnlyAutomation = !this.showOnlyAutomation;
          this.$nextTick(() => {
            this.updateLines();
          });
        },
        
        hasSpecialConnection(fromId, toId) {
          // 檢查兩個節點是否都在當前顯示的節點中
          const fromNode = this.filteredNodes.find(n => n.id === fromId);
          const toNode = this.filteredNodes.find(n => n.id === toId);
          return fromNode && toNode;
        },
        
        startDrag(e, index) {
          if (e.target.classList.contains('select-text') || e.target.closest('.select-text')) return;
          this.draggingIndex = index;
          const node = this.filteredNodes[index];
          this.offset.x = e.clientX - node.left;
          this.offset.y = e.clientY - node.top;
        },

        onDrag(e) {
          if (this.draggingIndex !== null) {
            const node = this.filteredNodes[this.draggingIndex];
            const boxWidth = 125;
            const boxHeight = 110;

            let newLeft = e.clientX - this.offset.x;
            let newTop = e.clientY - this.offset.y;

            newLeft = Math.max(0, Math.min(this.containerWidth - boxWidth, newLeft));
            newTop = Math.max(0, Math.min(this.containerHeight - boxHeight, newTop));

            node.left = newLeft;
            node.top = newTop;

            this.$nextTick(this.updateLines);
          }
        },
        
        endDrag() {
          this.draggingIndex = null;
        },
        
        getArrowPath(fromId, toId, direction) {
          let fromNode, toNode;
          
          if (this.showOnlyAutomation) {
            // 在自動化模式下，使用重新排列後的節點位置
            fromNode = this.filteredNodes.find(n => n.id === fromId);
            toNode = this.filteredNodes.find(n => n.id === toId);
          } else {
            // 在正常模式下，使用原始節點位置
            fromNode = this.filteredNodes.find(n => n.id === fromId);
            toNode = this.filteredNodes.find(n => n.id === toId);
          }
          
          if (!fromNode || !toNode) return '';
          
          const nodeWidth = 125;
          const nodeHeight = 110;
          
          const fromNodeLeft = fromNode.left + 60;
          const fromNodeTop = fromNode.top;
          const toNodeLeft = toNode.left + 60;
          const toNodeTop = toNode.top;
          
          if (direction === 'right') {
            const startX = fromNodeLeft + nodeWidth;
            const startY = fromNodeTop + nodeHeight / 2;
            const rightX = startX + 35;
            const endX = toNodeLeft;
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${rightX} ${startY} L ${rightX} ${endY} L ${endX} ${endY}`;
          } else {
            const startX = fromNodeLeft;
            const startY = fromNodeTop + nodeHeight / 2;
            const leftX = startX - 35;
            const endX = toNodeLeft + nodeWidth;
            const endY = toNodeTop + nodeHeight / 2;
            
            return `M ${startX} ${startY} L ${leftX} ${startY} L ${leftX} ${endY} L ${endX} ${endY}`;
          }
        },
        
        updateLines() {
          const boxWidth = 125;
          const boxHeight = 110;
          this.lines = [];
          
          const visibleNodes = this.filteredNodes;
          const cornerArrows = this.getCornerArrows();
          const cornerConnections = new Set(cornerArrows.map(arrow => `${arrow.fromId}-${arrow.toId}`));

          if (this.showOnlyAutomation) {
            // 自動化模式：根據實際排列順序連接，跳過轉彎箭頭
            for (let i = 0; i < visibleNodes.length - 1; i++) {
              const source = visibleNodes[i];
              const target = visibleNodes[i + 1];
              
              // 跳過轉彎箭頭的連接
              if (cornerConnections.has(`${source.id}-${target.id}`)) {
                continue;
              }
              
              const sx = source.left + boxWidth / 2;
              const sy = source.top + boxHeight / 2;
              const tx = target.left + boxWidth / 2;
              const ty = target.top + boxHeight / 2;

              const dx = tx - sx;
              const dy = ty - sy;
              const angle = Math.atan2(dy, dx);

              const offsetX = Math.cos(angle) * (boxWidth / 2);
              const offsetY = Math.sin(angle) * (boxHeight / 2);

              const x1 = sx + offsetX;
              const y1 = sy + offsetY;
              const x2 = tx - offsetX;
              const y2 = ty - offsetY;

              this.lines.push({ x1, y1, x2, y2 });
            }
          } else {
            // 正常模式：使用原始的 targets 連接邏輯
            for (const source of visibleNodes) {
              const sx = source.left + boxWidth / 2;
              const sy = source.top + boxHeight / 2;

              for (const targetId of source.targets) {
                const target = visibleNodes.find(n => n.id === targetId);
                if (!target) continue;

                // 跳過轉彎箭頭的連接
                if (cornerConnections.has(`${source.id}-${targetId}`)) {
                  continue;
                }

                const tx = target.left + boxWidth / 2;
                const ty = target.top + boxHeight / 2;

                const dx = tx - sx;
                const dy = ty - sy;
                const angle = Math.atan2(dy, dx);

                const offsetX = Math.cos(angle) * (boxWidth / 2);
                const offsetY = Math.sin(angle) * (boxHeight / 2);

                const x1 = sx + offsetX;
                const y1 = sy + offsetY;
                const x2 = tx - offsetX;
                const y2 = ty - offsetY;

                this.lines.push({ x1, y1, x2, y2 });
              }
            }
          }
        },
        
        getCornerArrows() {
          const corners = [];
          const visibleNodes = this.filteredNodes;
          const cols = 11;
          
          if (this.showOnlyAutomation) {
            // 自動化模式：根據實際排列計算轉彎箭頭
            for (let i = 0; i < visibleNodes.length; i++) {
              const row = Math.floor(i / cols);
              const col = i % cols;
              
              // 檢查是否是行末節點且有下一行
              const isLastInRow = (col === cols - 1) || (i === visibleNodes.length - 1);
              const nextRowStartIndex = (row + 1) * cols;
              
              if (isLastInRow && nextRowStartIndex < visibleNodes.length) {
                const currentNode = visibleNodes[i];
                const nextRowFirstNode = visibleNodes[nextRowStartIndex];
                
                if (currentNode && nextRowFirstNode) {
                  // 根據行數決定轉彎方向
                  const direction = row % 2 === 0 ? 'right' : 'left';
                  corners.push({
                    fromId: currentNode.id,
                    toId: nextRowFirstNode.id,
                    direction: direction
                  });
                }
              }
            }
          } else {
            // 正常模式：使用原始的固定轉彎邏輯
            const specialConnections = [
              { fromId: 11, toId: 12, direction: 'right' },
              { fromId: 22, toId: 23, direction: 'left' },
              { fromId: 33, toId: 34, direction: 'right' },
              { fromId: 44, toId: 45, direction: 'left' }
            ];
            
            for (const conn of specialConnections) {
              if (this.hasSpecialConnection(conn.fromId, conn.toId)) {
                corners.push(conn);
              }
            }
          }
          
          return corners;
        },
        
        getNodePosition(nodeId, nodeList) {
          const node = nodeList.find(n => n.id === nodeId);
          return node ? { left: node.left, top: node.top } : { left: 0, top: 0 };
        }
      }
    }).mount("#app");
  </script>
</body>
</html>